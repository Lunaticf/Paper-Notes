# Bitcoin: A Peer-to-Peer Electronic Cash System
区块链创世文-Satoshi Nakamoto

## Abstract
一个纯粹的点对点的交易系统可以让网上支付不需要第三方就可以实现。
数字签名是可以解决一部分问题的，但是仍然需要第三方机构来避免双花（double-spending）丢失了很多本来应有的优点。我们提出一个peer-to-peer的网络来解决double-spending问题。网络（节点组成的网络）给每一笔交易打上时间戳，并把这笔交易的哈希值放在一个持续增长的hash-based的工作量证明(pow)的链上。最长的链不仅可以为已经发生的一系列事情提供证明，还能证明这些事情来自于最大的CPU算力。只要大部分CPU算力是掌控在诚实的节点手里，这些节点就会形成出一条最长的链子并且甩开攻击者。整个网络只需要一个极小的组成结构，以方便信息尽最大努力广播给网络上的计算机节点（结构小传播的快）。节点可以随时加入和离开网络，并且回来的时候可以接收最长的链，知道他们走的时候发生了什么。
> 这段指出，现在有的技术可以实现p2p交易，用的就是数字签名。然而数字签名没有办法解决双花问题。因为数字签名只能保证这个东西是属于发送方的，但是没有办法保证这个东西发给一个人以后不会再发给其他人，因为数据是可以复制的。现有的方案就是发送方和接收方都信任一个第三方作为中介。由这个第三方记录A有一个东西，并把这个东西给了B完成了一笔交易。也就是这个第三方具有绝对的权利，而A和B都是因为“信任着”这个第三方交易才能成立。

## Introduction
现在的网络交易非常依赖于第三方的机构，虽然现有系统其实效果很好，但是基于此的turst model还是有很多weakness。
并且现在的交易是可以逆转的，因为金融机构不可避免地要调解矛盾。协调调解增加了交易的cost,限制了最小的实际交易规模并且切断了小型临时交易的可能。而商家也必须提防自己的客户，因此会向客户索取完全不必要的个人信息。而实际的商业行为中，一定比例的欺诈性客户也被认为是不可避免的，相关损失视作销售费用处理。 这种成本和不确定的交易是可被避免的当通过现实现金交易的方式，但是没有一个存在的机制来确保交易是通过一个没有可信方的通信通道进行支付的。
现在就需要一个密码学担保的电子支付系统，允许两方直接交易而不需要一个第三方。不可逆可以保护卖家，而常规的托管机制可以保护买家。本文提出一种通过点对点分布式的时间戳服务器来生成依照时间前后排列并加以记录的电子交易证明，来解决双花问题。只要诚实的节点所控制的计算能力的总和，大于攻击者的计算能力的总和，该系统就是安全的。

## Transactions
我们定义，一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。
这个过程的问题是收款人不能验证付款人中(one of the owners)没有双重支付货币。一个通常的解决方案是引入一个可信的中央认证，或铸币厂(mint)，来对每一笔交易检查是否被双重支付。在每一笔交易后，这个货币必须被返回到铸币场(mint)来发行一个新的货币(coin)，并且只有货币被直接的从可信的铸币厂发行才能保证不被双重支付。这个解决方案的问题是全部货币(money)的命运都依靠在这个公司运作的铸币厂(mint)上，每一笔交易都必须通过他们，就像一个银行一样。
我们需要给收款人(payee)一个方法去知道之前的拥有者们(owners)没有签署过更早的交易。对于这个目的，最早(earliest)的交易才是重要的，所以我们不必关心后面的交易是否尝试去双重支付。唯一的确保一个交易存在性的方法就是拥有查询所有的交易。在基于铸币厂模型中，这个铸币厂拥有所有的交易并且决定哪一个交易最新到达(which arrived first)。为了在没有一个可信任方的情况下完成这件事情，交易必须被公共公告，并且我们需要一个系统让所有参与者对只对在一个单链顺序历史(which they were received)上达成共识。收款人需要证明在每一次交易的期间，大多数节点都同意这是他们第一次收到的(was the firstreceived)。

## Timestamp-server
本解决方案首先提出一个“时间戳服务器”。时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播，就像在新闻或世界性新闻组网络（Usenet）的发帖一样。显然，该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，这样就形成了一个链条（Chain）。

## Proof of Work
为了在点对点的基础上构建一组分散化的时间戳服务器，仅仅像报纸或世界性新闻网络组一样工作是不够的，我们还需要一个类似于亚当•柏克（Adam Back）提出的哈希现金（Hashcash）。在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作，比方说SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，**而对结果进行检验则仅需要一次随机散列运算。**
我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。
同时，该工作量证明机制还解决了在集体投票表决时，谁是大多数的问题。如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，则该机制就被破坏了。而工作量证明机制的本质则是一CPU一票。“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对业已出现的区块进行修改，攻击者必须重新完成该区块的工作量外加该区块之后所有区块的工作量，并最终赶上和超越诚实节点的工作量。我们将在后文证明，设想一个较慢的攻击者试图赶上随后的区块，那么其成功概率将呈指数化递减。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。

## Networks
运行网络的步骤如下所示:
1. 新产生的交易被广播到所有节点
2. 每个节点打包新的交易到一个块中
3. 每个节点不断地计算来完成工作量证明
4. 节点挖到块后，广播到所有的节点
5. 节点只接收所有交易合法的块
6. 节点们通过转向下一个块的工作量证明并使用这个块的hash作为(下一个块的)前一个hash来表示接收这块。 
节点们总是只考虑最长的链是正确的并且不断为扩展它进行工作。如果2个节点同时广播不同版本的下一个块，一些节点会首先收到其中一个块，在这种情况下，他们为收到第一个块而工作，不过另一块保存下来以防它会变得更长。这个平衡(tie)将会被打破当下一个工作量证明被发现的时候并且这个时候一条分支会变得更长。在其他分支工作的节点们将会转换到这个最长的分支上。
新交易的广播到所有的节点上是不必要的。只要交易到达了许多节点上，它们就会进入到一个区块中(在最长的区块中(beforelong))。区块广播是有容忍丢失信息的能力的。如果一个节点没有收到一个块，它就会在收到下一个块的时候发现缺失了它并请求这个丢失的块。
-> 交易是不需要泛洪的。因为想扩散交易本身的信息，在区块链系统中可以不止扩散交易，还扩散区块。而区块被扩散是系统中的“规则”(达到最长链)。我认为这可以带来分布式系统中的一些新的思考。

## Incentive
按照惯例(进行约定)，一个块中的第一个交易是一个特殊交易，它由这个块的创造者拥有一个新货币起始。这样提供了一种激励机制让节点们能够支撑这个网络，并且提供了一个方式来初始化的分发货币进入整个系统当中。因为没有一个中央授权机构来发布他们(货币)。稳定增加一定数量的新货币类似于黄金矿工花费资源开采黄金并引入循环系统当中。在我们的情境下，CPU时间和电力就是被花费的。
这种激励机制同样可以以交易手续费的方式奖励。如果一个交易的输出值小于其输入值，那么这个差值就是交易的手续费，手续费被附加到包含这个交易的区块的奖励中。一旦一个已决定数目的货币(所有货币)进入这个循环中，这个激励机制就可完全的转变为交易手续费并且本系统可以完全避免通货膨胀(货币总数一定，没有发行货币)。
激励机制可能会帮助鼓励节点们保持诚实。如果一个贪婪的攻击者能够收集到比起所有诚实节点更多的CPU算力，他就面临	一个选择：要么用这个算力来用于二次支付来欺骗别人，或者使用算力来生成更多的货币。他应该会发现跟着规则来能获得更多的利益，这样的规则支撑他比起其他加入进来的人能够拥有更多的货币，而不是破坏这个系统使得自己的财富受损。
## Reclaming Disk Space
一旦一个货币最新的交易收入(buried)进入足够的区块中，那么在这个交易前面被消费过的交易就能够被抛弃来节省硬盘资源。为了同时确保不损害区块的hash，交易被hash为一棵Merkle Tree7[5]，这个Merkel Tree只有root节点被包含进了这个区块的hash。老的区块能够被压缩通过将这个树的分支进行拔除(stubbing off branches of thetree)。而内部的hash是不必被保存的。
一个剔除交易的区块头大概会是80byte大小。如果我们假设区块每10分钟就生成一个，那么80bytes * 6 * 25 * 365 = 4.2MB 每年。2008 年PC系统通常的内存容量为2GB，按照摩尔定理预言的每年增长1.2GB的大小，即使将全部的区块头存储在内存之中都不是问题。

## Simplified Payment Verification
在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。
当此情形，只要诚实的节点控制了网络，检验机制就是可靠的。但是，当全网被一个计算力占优的攻击者攻击时，将变得较为脆弱。因为网络节点能够自行确认交易的有效性，只要攻击者能够持续地保持计算力优势，简化的机制会被攻击者焊接的（fabricated）交易欺骗。那么一个可行的策略就是，只要他们发现了一个无效的区块，就立刻发出警报，收到警报的用户将立刻开始下载被警告有问题的区块或交易的完整信息，以便对信息的不一致进行判定。对于日常会发生大量收付的商业机构，可能仍会希望运行他们自己的完整节点，以保持较大的独立完全性和检验的快速性。

## Combining and Spliting Value
虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。

## Privacy
传统的银行模型实现隐私的等级是通过限制访问信息给相关的参与者和第三方。当需要将全部交易公开广播的时候，就不能使用这种方法了。但是隐私仍然能够被维护通过打破在另一个地方的信息流：通过使公钥匿名的形式。公众可以看到有一个人发送了一笔数目给另一个人，但是没有信息能把交易和人联系在一起。这和股票交易中释放的信息等级类似，在股票交易中公开发布的时间和个人的交易是记录在案的"tape"，但是是不会告知是谁参与进来。
作为附加的防火墙(防范机制)，在每次交易中都使用一个新的密钥对能够保证把这些密钥和一个人联系起来。一些多笔输入的交易的联系仍然是不可避免的，因为在这点(多笔输入)揭示了上这些输入是属于同一个人的。风险就在于，如果只要其中一个key的拥有者被发现了，那么相关联的属于这个人的其他交易也会被揭示。

## Calculation
设想如下场景：一个攻击者试图比诚实节点产生链条更快地制造替代性区块链。即便它达到了这一目的，但是整个系统也并非就此完全受制于攻击者的独断意志了，比方说凭空创造价值，或者掠夺本不属于攻击者的货币。这是因为节点将不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 诚实链条和攻击者链条之间的竞赛，可以用二叉树随机漫步（Binomial Random Walk)来描述。成功事件定义为诚实链条延长了一个区块，使其领先性+1，而失败事件则是攻击者的链条被延长了一个区块，使得差距-1。 攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题（Gambler’s Ruin problem）。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数为无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填补上亏空的概率，也就是该攻击者赶上诚实链条
假定p>q，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝就变得愈发渺茫。那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了，然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。 收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。 然后收款人将等待交易出现在首个区块中，然后在等到z个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将耗费平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为：

## Conclusion
我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的CPU计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的CPU计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个P2P电子货币系统所需要的全部规则和激励措施。